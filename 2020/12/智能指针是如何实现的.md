C++ 标准一共有四种智能指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中 auto_ptr 在 C++11 已被摒弃，C++17 中被移除。

这篇文章就依次看看这四种智能指针的实现原理，只有当我们了解其实现原理，在实际使用的时候才能游刃有余。

## auto_ptr

auto_ptr 虽然已被废弃，但作为 C++ 的第一个智能指针，我们还是要学习下。以下代码节选自 [libstdc++-v3/include/backward/auto_ptr.h](https://code.woboq.org/gcc/libstdc++-v3/include/backward/auto_ptr.h.html)，并作稍微修改，

```c++
template<typename _Tp>
class auto_ptr
{
private:
    _Tp* _M_ptr;

public:
    typedef _Tp element_type;

    explicit auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
    
    // tag 1
    auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }

    // tag 2
    template<typename _Tp1>
    auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }

    auto_ptr& operator=(auto_ptr& __a) throw()
    {
        reset(__a.release());
        return *this;
    }

    template<typename _Tp1>
    auto_ptr& operator=(auto_ptr<_Tp1>& __a) throw()
    {
        reset(__a.release());
        return *this;
    }

    // tag 3
    ~auto_ptr() { delete _M_ptr; }

    element_type& operator*() const throw()
    {
        __glibcxx_assert(_M_ptr != 0);
        return *_M_ptr;
    }

    element_type* operator->() const throw()
    {
        __glibcxx_assert(_M_ptr != 0);
        return _M_ptr;
    }

    element_type* get() const throw() { return _M_ptr; }

    element_type* release() throw()
    {
        element_type* __tmp = _M_ptr;
        _M_ptr = 0;
        return __tmp;
    }

    void reset(element_type* __p = 0) throw()
    {
        if (__p != _M_ptr)
        {
            delete _M_ptr;
            _M_ptr = __p;
        }
    }

    // tag 4
    template<typename _Tp1>
    operator auto_ptr<_Tp1>() throw()
    { return auto_ptr<_Tp1>(this->release()); }
};
```

代码很简单，但有几处还需要再说下。

tag 1 和 tag 2 有什么区别呢？这其实就是一个模板的小知识。auto_ptr 是一个模板类，

```c++
template<typename _Tp>
class auto_ptr;
```

它的构造函数的参数 `__a`，既可以与 this 是同一个模板类型（即 _Tp），也可以是一个不同的模板类型（即代码所写的 _Tp1）。很明显，tag 2 属于后者。但注意， _Tp1 与 _Tp 应该是子类与父类的关系，否则会编译失败。

tag 3 处的析构函数可以明显看出，类型 _Tp 的默认析构必须是标准 delete，而无法是用户自定义的 deleter，这是有区别于接下来要讲的其它的智能指针的。

tag 4 处，这其实是类型转换运算符（Type Conversion Operator）重载，有些读者可能会和函数调用运算符（Function Call Operator）重载搞混，具体区别可参考 [C++ operator() parenthesis - operator Type() vs Type operator()](https://stackoverflow.com/questions/44247797/c-operator-parenthesis-operator-type-vs-type-operator)。

## unique_ptr

以下代码节选自 [libstdc++-v3/include/bits/unique_ptr.h](https://code.woboq.org/gcc/libstdc++-v3/include/bits/unique_ptr.h.html)，并作稍微修改，

```c++
template <typename _Tp, typename _Dp = default_delete<_Tp>>
class unique_ptr
{
public:
    using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
    using element_type = _Tp;
    using deleter_type = _Dp;

    // Constructors.
    /// Default constructor, creates a unique_ptr that owns nothing.
    template <typename _Up = _Dp,
              typename = _DeleterConstraint<_Up>>
    constexpr unique_ptr() noexcept
        : _M_t()
    {
    }
    /** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       *
       * The deleter will be value-initialized.
       */
    template <typename _Up = _Dp,
              typename = _DeleterConstraint<_Up>>
    explicit unique_ptr(pointer __p) noexcept
        : _M_t(__p)
    {
    }
    /** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       * @param __d  A reference to a deleter.
       *
       * The deleter will be initialized with @p __d
       */
    unique_ptr(pointer __p,
               typename conditional<is_reference<deleter_type>::value,
                                    deleter_type, const deleter_type &>::type __d) noexcept
        : _M_t(__p, __d) {}
    /** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       * @param __d  An rvalue reference to a deleter.
       *
       * The deleter will be initialized with @p std::move(__d)
       */
    unique_ptr(pointer __p,
               typename remove_reference<deleter_type>::type &&__d) noexcept
        : _M_t(std::move(__p), std::move(__d))
    {
        static_assert(!std::is_reference<deleter_type>::value,
                      "rvalue deleter bound to reference");
    }
    /// Creates a unique_ptr that owns nothing.
    template <typename _Up = _Dp,
              typename = _DeleterConstraint<_Up>>
    constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() {}
    // Move constructors.
    /// Move constructor.
    unique_ptr(unique_ptr &&__u) noexcept
        : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}
    /** @brief Converting constructor from another type
       *
       * Requires that the pointer owned by @p __u is convertible to the
       * type of pointer owned by this object, @p __u does not own an array,
       * and @p __u has a compatible deleter type.
       */
    template <typename _Up, typename _Ep, typename = _Require<__safe_conversion_up<_Up, _Ep>, typename conditional<is_reference<_Dp>::value, is_same<_Ep, _Dp>, is_convertible<_Ep, _Dp>>::type>>
    unique_ptr(unique_ptr<_Up, _Ep> &&__u) noexcept
        : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
    {
    }
#if _GLIBCXX_USE_DEPRECATED
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    /// Converting constructor from @c auto_ptr
    template <typename _Up, typename = _Require<
                                is_convertible<_Up *, _Tp *>, is_same<_Dp, default_delete<_Tp>>>>
    unique_ptr(auto_ptr<_Up> &&__u) noexcept;
#pragma GCC diagnostic pop
#endif
    /// Destructor, invokes the deleter if the stored pointer is not null.
    ~unique_ptr() noexcept
    {
        auto &__ptr = _M_t._M_ptr();
        if (__ptr != nullptr)
            get_deleter()(__ptr);
        __ptr = pointer();
    }
    // Assignment.
    /** @brief Move assignment operator.
       *
       * @param __u  The object to transfer ownership from.
       *
       * Invokes the deleter first if this object owns a pointer.
       */
    unique_ptr &
    operator=(unique_ptr &&__u) noexcept
    {
        reset(__u.release());
        get_deleter() = std::forward<deleter_type>(__u.get_deleter());
        return *this;
    }
    /** @brief Assignment from another type.
       *
       * @param __u  The object to transfer ownership from, which owns a
       *             convertible pointer to a non-array object.
       *
       * Invokes the deleter first if this object owns a pointer.
       */
    template <typename _Up, typename _Ep>
    typename enable_if<__and_<
                           __safe_conversion_up<_Up, _Ep>,
                           is_assignable<deleter_type &, _Ep &&>>::value,
                       unique_ptr &>::type
    operator=(unique_ptr<_Up, _Ep> &&__u) noexcept
    {
        reset(__u.release());
        get_deleter() = std::forward<_Ep>(__u.get_deleter());
        return *this;
    }
    /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
    unique_ptr &
    operator=(nullptr_t) noexcept
    {
        reset();
        return *this;
    }
    // Observers.
    /// Dereference the stored pointer.
    typename add_lvalue_reference<element_type>::type
    operator*() const
    {
        __glibcxx_assert(get() != pointer());
        return *get();
    }
    /// Return the stored pointer.
    pointer
    operator->() const noexcept
    {
        _GLIBCXX_DEBUG_PEDASSERT(get() != pointer());
        return get();
    }
    /// Return the stored pointer.
    pointer
    get() const noexcept
    {
        return _M_t._M_ptr();
    }
    /// Return a reference to the stored deleter.
    deleter_type &
    get_deleter() noexcept
    {
        return _M_t._M_deleter();
    }
    /// Return a reference to the stored deleter.
    const deleter_type &
    get_deleter() const noexcept
    {
        return _M_t._M_deleter();
    }
    /// Return @c true if the stored pointer is not null.
    explicit operator bool() const noexcept
    {
        return get() == pointer() ? false : true;
    }
    // Modifiers.
    /// Release ownership of any stored pointer.
    pointer
    release() noexcept
    {
        pointer __p = get();
        _M_t._M_ptr() = pointer();
        return __p;
    }
    /** @brief Replace the stored pointer.
       *
       * @param __p  The new pointer to store.
       *
       * The deleter will be invoked if a pointer is already owned.
       */
    void
    reset(pointer __p = pointer()) noexcept
    {
        using std::swap;
        swap(_M_t._M_ptr(), __p);
        if (__p != pointer())
            get_deleter()(__p);
    }
    /// Exchange the pointer and deleter with another object.
    void
    swap(unique_ptr &__u) noexcept
    {
        using std::swap;
        swap(_M_t, __u._M_t);
    }
    // Disable copy from lvalue.
    unique_ptr(const unique_ptr &) = delete;
    unique_ptr &operator=(const unique_ptr &) = delete;
};
```









## shared_ptr 和 weak_ptr