C++ 标准一共有四种智能指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中 auto_ptr 在 C++11 已被摒弃，C++17 中被移除。

这篇文章就依次看看这四种智能指针的实现原理，只有当我们了解其实现原理，在实际使用的时候才能游刃有余。

## auto_ptr

auto_ptr 虽然已被废弃，但作为 C++ 的第一个智能指针，我们还是要学习下，它的内容很简单。以下代码节选自 [libstdc++-v3/include/backward/auto_ptr.h](https://code.woboq.org/gcc/libstdc++-v3/include/backward/auto_ptr.h.html)，并作稍微修改，

```c++
template<typename _Tp>
class auto_ptr
{
private:
    _Tp* _M_ptr;

public:
    typedef _Tp element_type;

    explicit auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
    auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }

    template<typename _Tp1>
    auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }

    auto_ptr& operator=(auto_ptr& __a) throw()
    {
        reset(__a.release());
        return *this;
    }

    template<typename _Tp1>
    auto_ptr& operator=(auto_ptr<_Tp1>& __a) throw()
    {
        reset(__a.release());
        return *this;
    }

    ~auto_ptr() { delete _M_ptr; }

    element_type& operator*() const throw()
    {
        __glibcxx_assert(_M_ptr != 0);
        return *_M_ptr;
    }

    element_type* operator->() const throw()
    {
        __glibcxx_assert(_M_ptr != 0);
        return _M_ptr;
    }

    element_type* get() const throw() { return _M_ptr; }

    element_type* release() throw()
    {
        element_type* __tmp = _M_ptr;
        _M_ptr = 0;
        return __tmp;
    }

    void reset(element_type* __p = 0) throw()
    {
        if (__p != _M_ptr)
        {
            delete _M_ptr;
            _M_ptr = __p;
        }
    }

    /**
     *  @brief  Automatic conversions
     *
     *  These operations are supposed to convert an %auto_ptr into and from
     *  an auto_ptr_ref automatically as needed.  This would allow
     *  constructs such as
     *  @code
     *    auto_ptr<Derived>  func_returning_auto_ptr(.....);
     *    ...
     *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);
     *  @endcode
     *
     *  But it doesn't work, and won't be fixed. For further details see
     *  http://cplusplus.github.io/LWG/lwg-closed.html#463
     */
    auto_ptr(auto_ptr_ref<element_type> __ref) throw()
        : _M_ptr(__ref._M_ptr) { }

    auto_ptr& operator=(auto_ptr_ref<element_type> __ref) throw()
    {
        if (__ref._M_ptr != this->get())
        {
            delete _M_ptr;
            _M_ptr = __ref._M_ptr;
        }
        return *this;
    }

    template<typename _Tp1>
    operator auto_ptr<_Tp1>() throw()
    { return auto_ptr<_Tp1>(this->release()); }
};
```

对于代码段末尾处的 `operator auto_ptr<_Tp1>()`，有些读者可能会和函数调用运算符（Function Call Operator）重载搞混，具体区别可参考 [C++ operator() parenthesis - operator Type() vs Type operator()](https://stackoverflow.com/questions/44247797/c-operator-parenthesis-operator-type-vs-type-operator)。
